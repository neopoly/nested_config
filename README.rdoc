= nested_config

Simple, static, nested application configuration

Gem[https://rubygems.org/gems/nested_config] |
Source[https://github.com/neopoly/nested_config] |
RDoc[http://rubydoc.info/github/neopoly/nested_config/master/file/README.rdoc] |
{<img src="https://secure.travis-ci.org/neopoly/nested_config.png?branch=master" alt="Build Status" />}[http://travis-ci.org/neopoly/nested_config]

== Usage

  require 'nested_config'

  class MyApp
    def self.configure
      yield config
    end

    def self.config
      @config ||= MyConfig.new
    end

    class MyConfig < NestedConfig
    end
  end

=== Basic

  MyApp.configure do |config|
    config.coins = 1000
    config.user do |user|
      user.max = 5
    end
    config.queue do |queue|
      queue.workers do |workers|
        workers.max = 2
        workers.timeout = 60.seconds
      end
    end
  end

  MyApp.config.coins # => 1000
  MyApp.config.queue.workers.timeout # => 60


=== EvaluateOnce

With the module +EvaluateOnce+ you can define config value which will be evaluated lazily. Once.

  class MyConfig
    include NestedConfig::EvaluateOnce
  end

  MyApp.configure do |config|
    config.country_list = proc { Country.all }
  end

  MyApp.config.country_list # => [List of countries]
  MyApp.config.country_list # => [List of countries] (cached)

The initial access to key +country_list+ calls (via +call+ method) the proc and replaces the value.
Subsequent calls just fetch the replaced value.


=== Cloning

NestedConfig can be cloned via +__clone__+ method

  clone = MyApp.config.__clone__
  clone.coins = 2000
  MyApp.config.conins # => 1000

*Note*: Proc values CANNOT be cloned.

=== Key names

*Note*: NestedConfig is not a blank slate so you CANNOT use defined method names as keys like +object_id+.

== Installation

  gem install nested_config

== Test

  rake test
  COVERAGE=1 rake test

== Release

  edit lib/nested_config/version.rb
  rake release
